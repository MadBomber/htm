# frozen_string_literal: true

require "test_helper"

class OntologyTest < Minitest::Test
  def setup
    # Skip if database is not configured
    unless ENV['HTM_DBURL']
      skip "Database not configured. Set HTM_DBURL to run ontology tests."
    end

        @htm = HTM.new(
      robot_name: "Ontology Test Robot")
  end

    def test_manual_topic_assignment
    # Add a node with manual hierarchical tags
    node_id = @htm.remember(
      "PostgreSQL with TimescaleDB provides efficient time-series data storage using hypertables and compression policies",
      speaker: "user",
      tags: ["database:postgresql:timescaledb", "storage:time-series", "performance:optimization"]
    )

    assert_instance_of Integer, node_id

    # Query the tags table for assigned topics
    topics = get_node_topics(node_id)

    # Verify topics were assigned
    refute_empty topics, "Topics should have been assigned manually"

    # Verify hierarchical structure (should contain colons)
    hierarchical_topics = topics.select { |t| t.include?(':') }
    refute_empty hierarchical_topics, "Should have hierarchical topics with colon separators"

    # Verify expected topics
    assert_includes topics, "database:postgresql:timescaledb"
    assert_includes topics, "storage:time-series"
    assert_includes topics, "performance:optimization"

    # Clean up
    delete_node(node_id)
  end

  def test_topic_format_validation
    # Add a node with properly formatted hierarchical tags
    node_id = @htm.remember(
      "Ruby on Rails is a web framework for building database-backed applications",
      speaker: "user",
      tags: ["web:frameworks:rails", "programming:ruby", "database:orm"]
    )

    topics = get_node_topics(node_id)

    # Verify all topics match the expected format: lowercase, hyphens, colons
    topics.each do |topic|
      assert_match(/^[a-z0-9\-]+(:[a-z0-9\-]+)*$/, topic,
        "Topic '#{topic}' should match format: root:level1:level2")
    end

    # Clean up
    delete_node(node_id)
  end

  def test_multiple_classification_paths
    # Add a node with tags from multiple perspectives
    node_id = @htm.remember(
      "Machine learning models for database query optimization can improve performance by 30-50%",
      speaker: "user",
      tags: ["ai:machine-learning:optimization", "database:performance:query-optimization", "performance:improvement"]
    )

    topics = get_node_topics(node_id)

    # Verify multiple topic hierarchies exist
    root_topics = topics.map { |t| t.split(':').first }.uniq

    # Should have topics from multiple domains
    assert root_topics.length >= 2,
      "Should have multiple classification paths (got: #{root_topics.join(', ')})"

    # Clean up
    delete_node(node_id)
  end

  def test_manual_tag_updates
    # Add a node with initial tags
    node_id = @htm.remember(
      "Initial content about Ruby programming",
      speaker: "user",
      tags: ["programming:ruby", "language:interpreted"]
    )

    initial_topics = get_node_topics(node_id)
    assert_includes initial_topics, "programming:ruby"

    # Manually update tags by deleting old ones and adding new ones
    delete_node_tags(node_id)
    add_node_tags(node_id, ["database:postgresql:performance", "optimization:query"])

    updated_topics = get_node_topics(node_id)

    # Topics should have changed
    refute_equal initial_topics.sort, updated_topics.sort,
      "Topics should change when manually updated"

    # New topics should be present
    assert_includes updated_topics, "database:postgresql:performance"
    assert_includes updated_topics, "optimization:query"

    # Old topics should be gone
    refute_includes updated_topics, "programming:ruby"

    # Clean up
    delete_node(node_id)
  end

  def test_ontology_structure_view
    # Add several nodes with related hierarchical tags
    nodes = []
    3.times do |i|
      nodes << @htm.remember(
        "PostgreSQL database content number #{i}",
        speaker: "user",
        tags: ["database:postgresql", "storage:relational"]
      )
    end

    # Query the ontology_structure view
    structure = query_ontology_structure

    # Verify the view returns results
    refute_empty structure, "Ontology structure view should return data"

    # Verify structure has expected columns
    first_row = structure.first
    assert first_row.key?('root_topic'), "Should have root_topic column"
    assert first_row.key?('full_path'), "Should have full_path column"
    assert first_row.key?('node_count'), "Should have node_count column"

    # Clean up
    nodes.each { |node_id| delete_node(node_id) }
  end

  def test_topic_uniqueness_per_node
    # Add a node with tags (database enforces uniqueness via UNIQUE constraint)
    node_id = @htm.remember(
      "Ruby programming language",
      speaker: "user",
      tags: ["programming:ruby", "language:interpreted", "programming:ruby"]  # Duplicate intentionally
    )

    topics = get_node_topics(node_id)
    unique_topics = topics.uniq

    # Verify no duplicate topics for this node (database enforces this)
    assert_equal topics.length, unique_topics.length,
      "Should not have duplicate topics for a single node"

    # Clean up
    delete_node(node_id)
  end

  def test_node_creation_without_tags
    # Verify that node creation succeeds even without tags
    node_id = @htm.remember(
      "Test content without tags",
      speaker: "user"
    )

    # Node should be created successfully
    assert_instance_of Integer, node_id

    topics = get_node_topics(node_id)
    assert_empty topics, "Should have no topics when none provided"

    # Clean up
    delete_node(node_id)
  end

  def test_topic_depth_limit
    # Add a node with deep hierarchy tags
    node_id = @htm.remember(
      "TimescaleDB continuous aggregates with real-time materialization for time-series analytics",
      speaker: "user",
      tags: [
        "database:timescaledb:features:continuous-aggregates",
        "analytics:time-series:real-time"
      ]
    )

    topics = get_node_topics(node_id)

    # Verify topics don't exceed reasonable depth (max 5 levels)
    topics.each do |topic|
      levels = topic.split(':').length
      assert levels <= 5, "Topic '#{topic}' exceeds maximum depth of 5 (has #{levels} levels)"
    end

    # Clean up
    delete_node(node_id)
  end

  def test_topic_relationships_view
    # Add multiple nodes with overlapping tags
    nodes = []
    nodes << @htm.remember("PostgreSQL basics", speaker: "user",
                              tags: ["database:postgresql", "sql:basics"])
    nodes << @htm.remember("PostgreSQL advanced features", speaker: "user",
                              tags: ["database:postgresql", "sql:advanced"])
    nodes << @htm.remember("Database design", speaker: "user",
                              tags: ["database:design", "architecture"])

    # Query topic relationships view
    relationships = query_topic_relationships

    # If we have relationships, verify structure
    unless relationships.empty?
      first_rel = relationships.first
      assert first_rel.key?('topic1'), "Should have topic1 column"
      assert first_rel.key?('topic2'), "Should have topic2 column"
      assert first_rel.key?('shared_nodes'), "Should have shared_nodes column"

      # Should show that database:postgresql co-occurs with sql:basics and sql:advanced
      assert relationships.any? { |r|
        (r['topic1'] == 'database:postgresql' || r['topic2'] == 'database:postgresql') &&
        r['shared_nodes'].to_i >= 2
      }, "Should have relationship for database:postgresql appearing in multiple nodes"
    end

    # Clean up
    nodes.each { |node_id| delete_node(node_id) }
  end

  def test_empty_tag_array_no_topics
    # Add a node with empty tags array
    node_id = @htm.remember(
      "Content with empty tags array",
      speaker: "user",
      tags: []
    )

    topics = get_node_topics(node_id)

    # Should have no topics
    assert_empty topics, "Should have no topics with empty tags array"

    # Clean up
    delete_node(node_id)
  end

  private

  # Helper method to get topics for a node
  def get_node_topics(node_id)
    @htm.long_term_memory.send(:with_connection) do |conn|
      result = conn.exec_params(
        "SELECT tag FROM tags WHERE node_id = $1 ORDER BY tag",
        [node_id]
      )
      result.map { |row| row['tag'] }
    end
  end

  # Helper method to delete a node by ID
  def delete_node(node_id)
    @htm.long_term_memory.send(:with_connection) do |conn|
      conn.exec_params("DELETE FROM nodes WHERE id = $1", [node_id])
    end
  end

  # Helper method to delete all tags for a node
  def delete_node_tags(node_id)
    @htm.long_term_memory.send(:with_connection) do |conn|
      conn.exec_params("DELETE FROM tags WHERE node_id = $1", [node_id])
    end
  end

  # Helper method to add tags to a node
  def add_node_tags(node_id, tags)
    @htm.long_term_memory.send(:with_connection) do |conn|
      tags.each do |tag|
        conn.exec_params(
          "INSERT INTO tags (node_id, tag) VALUES ($1, $2) ON CONFLICT DO NOTHING",
          [node_id, tag]
        )
      end
    end
  end

  # Helper method to query ontology structure view
  def query_ontology_structure
    @htm.long_term_memory.send(:with_connection) do |conn|
      result = conn.exec("SELECT * FROM ontology_structure LIMIT 10")
      result.to_a
    end
  end

  # Helper method to query topic relationships view
  def query_topic_relationships
    @htm.long_term_memory.send(:with_connection) do |conn|
      result = conn.exec("SELECT * FROM topic_relationships LIMIT 10")
      result.to_a
    end
  end
end
