# frozen_string_literal: true

namespace :htm do
  namespace :doc do
    desc "Build YARD API documentation (markdown format for MkDocs)"
    task :yard do
      require "fileutils"

      output_dir = "docs/api/yard"

      puts "Building YARD documentation (markdown format)..."
      puts "Output directory: #{output_dir}"
      puts

      # Clean previous output
      FileUtils.rm_rf(output_dir) if Dir.exist?(output_dir)
      FileUtils.mkdir_p(output_dir)

      # Build YARD documentation in markdown format
      # Requires yard-markdown plugin to be installed
      options = [
        "--plugin markdown",
        "--output-dir #{output_dir}",
        "--format markdown",
        "--title 'HTM - Hierarchical Temporary Memory API'",
        "--markup markdown",
        "--charset utf-8",
        "--protected",
        "--no-private",
        "lib/**/*.rb",
        "-",
        "README.md",
        "CHANGELOG.md"
      ]

      system("yard doc #{options.join(' ')}")

      if $?.success?
        # Create MkDocs index page for the YARD docs
        create_yard_index_page(output_dir)

        puts
        puts "Documentation built successfully!"
        puts "YARD docs: #{output_dir}/"
        puts "MkDocs index: docs/api/yard-reference.md"
      else
        puts
        puts "Failed to build documentation. Make sure YARD and yard-markdown are installed:"
        puts "  gem install yard yard-markdown"
        exit 1
      end
    end

    def create_yard_index_page(yard_output_dir)
      # Generate list of documented classes/modules from YARD output
      class_list = extract_yard_classes(yard_output_dir)

      content = <<~MARKDOWN
        # YARD API Reference

        Complete API documentation generated by [YARD](https://yardoc.org/) with [yard-markdown](https://github.com/skatkov/yard-markdown).

        <div class="grid cards" markdown>

        -   :material-book-open-variant:{ .lg .middle } **API Documentation**

            ---

            Browse the complete API reference with method signatures, parameters, and examples.

        -   :material-chart-bar:{ .lg .middle } **Documentation Coverage**

            ---

            Run `rake htm:doc:stats` to see documentation coverage statistics.

        </div>

        ## Classes & Modules

        | Class/Module | Description |
        |--------------|-------------|
        #{class_list}

        ## Generating Documentation

        ```bash
        # Build YARD documentation
        rake htm:doc:yard

        # Start live-reload server (HTML mode)
        rake htm:doc:server

        # Show coverage statistics
        rake htm:doc:stats
        ```
      MARKDOWN

      File.write("docs/api/yard-reference.md", content)
    end

    def extract_yard_classes(yard_output_dir)
      # Class descriptions for known classes
      descriptions = {
        "HTM" => "Main API class for memory operations",
        "Configuration" => "Multi-provider LLM configuration",
        "Database" => "Database schema and connection management",
        "EmbeddingService" => "Vector embedding generation service",
        "LongTermMemory" => "PostgreSQL-backed permanent storage",
        "WorkingMemory" => "Token-limited in-memory cache",
        "TagService" => "Hierarchical tag extraction service",
        "Observability" => "Metrics and logging instrumentation",
        "CircuitBreaker" => "Fault tolerance for external services",
        "Timeframe" => "Time-based query filtering",
        "TimeframeExtractor" => "Natural language time parsing",
        "JobAdapter" => "Background job abstraction layer"
      }

      # Dynamically discover classes from YARD markdown output
      classes = []

      # Check for markdown files in output directory
      Dir.glob(File.join(yard_output_dir, "**/*.md")).sort.each do |file|
        relative_path = file.sub("#{yard_output_dir}/", "")
        basename = File.basename(file, ".md")

        # Skip index files and non-class files
        next if basename == "index" || basename == "_index"
        next if basename.start_with?("_")

        # Determine class name from path
        class_name = relative_path.sub(".md", "").gsub("/", "::")

        # Skip error classes and internal classes
        next if class_name.end_with?("Error")
        next if class_name.include?("Railtie")
        next if class_name.include?("ActiveRecordConfig")

        # Get description
        simple_name = basename
        desc = descriptions[simple_name] || "#{class_name} class"

        classes << [class_name, desc, "yard/#{relative_path}"]
      end

      # If no markdown files found, fall back to checking for HTML (in case yard-markdown not installed)
      if classes.empty?
        htm_file = File.join(yard_output_dir, "HTM.html")
        if File.exist?(htm_file)
          classes << ["HTM", descriptions["HTM"] || "Main module", "yard/HTM.html"]
        end

        htm_dir = File.join(yard_output_dir, "HTM")
        if Dir.exist?(htm_dir)
          Dir.glob(File.join(htm_dir, "*.html")).sort.each do |file|
            basename = File.basename(file, ".html")
            next if basename.end_with?("Error")
            next if basename == "Railtie"
            next if basename == "ActiveRecordConfig"

            desc = descriptions[basename] || "#{basename} class"
            classes << ["HTM::#{basename}", desc, "yard/HTM/#{basename}.html"]
          end
        end
      end

      classes.map do |name, desc, path|
        "| [#{name}](#{path}) | #{desc} |"
      end.join("\n")
    end

    desc "Start YARD documentation server (live reload)"
    task :server, [:port] do |_t, args|
      port = args[:port] || 8808

      puts "Starting YARD documentation server on http://localhost:#{port}"
      puts "Press Ctrl+C to stop"
      puts

      exec("yard server --reload --port #{port}")
    end

    desc "Show documentation coverage statistics"
    task :stats do
      puts "YARD Documentation Coverage:"
      puts
      system("yard stats --list-undoc lib/**/*.rb")
    end

    desc "Clean generated documentation"
    task :clean do
      require "fileutils"

      dirs_to_clean = ["docs/api/yard", ".yardoc"]
      files_to_clean = ["docs/api/yard-reference.md"]

      dirs_to_clean.each do |dir|
        if Dir.exist?(dir)
          FileUtils.rm_rf(dir)
          puts "Removed: #{dir}"
        end
      end

      files_to_clean.each do |file|
        if File.exist?(file)
          FileUtils.rm(file)
          puts "Removed: #{file}"
        end
      end

      puts "Documentation cleaned."
    end
  end
end
