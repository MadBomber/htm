# frozen_string_literal: true

namespace :htm do
  namespace :doc do
    desc "Build YARD API documentation (markdown format for MkDocs)"
    task :yard do
      require "fileutils"

      output_dir = "docs/api/yard"

      puts "Building YARD documentation (markdown format)..."
      puts "Output directory: #{output_dir}"
      puts

      # Clean previous output
      FileUtils.rm_rf(output_dir) if Dir.exist?(output_dir)
      FileUtils.mkdir_p(output_dir)

      # Build YARD documentation in markdown format
      # Requires yard-markdown plugin to be installed
      options = [
        "--plugin markdown",
        "--output-dir #{output_dir}",
        "--format markdown",
        "--title 'HTM - Hierarchical Temporary Memory API'",
        "--markup markdown",
        "--charset utf-8",
        "--protected",
        "--no-private",
        "lib/**/*.rb",
        "-",
        "README.md",
        "CHANGELOG.md"
      ]

      system("yard doc #{options.join(' ')}")

      if $?.success?
        # Post-process markdown files for MkDocs compatibility
        fix_yard_anchors_for_mkdocs(output_dir)

        # Create MkDocs index page for the YARD docs
        create_yard_index_page(output_dir)

        puts
        puts "Documentation built successfully!"
        puts "YARD docs: #{output_dir}/"
        puts "MkDocs index: docs/api/yard-reference.md"
      else
        puts
        puts "Failed to build documentation. Make sure YARD and yard-markdown are installed:"
        puts "  gem install yard yard-markdown"
        exit 1
      end
    end

    # Convert YARD anchor format to MkDocs-compatible format
    # YARD generates: ## method_name() [](#method-i-method_name)
    # MkDocs needs:   ## method_name() {: #method-i-method_name }
    #
    # Also escapes YARD annotations (@param, @return, etc.) to prevent
    # pymdownx.magiclink from treating them as GitHub @mentions
    def fix_yard_anchors_for_mkdocs(output_dir)
      files_fixed = 0
      anchors_fixed = 0
      mentions_escaped = 0

      Dir.glob(File.join(output_dir, "**/*.md")).each do |file|
        content = File.read(file)
        original = content.dup

        # Pattern 0: Fix malformed YARD output where code fence is joined with heading
        # "```## method_name() [](#anchor)" -> "```\n## method_name() {: #anchor }"
        content.gsub!(%r{^(```)(\#{1,6}\s+.+?)\s*\[\]\(\#([^)]+)\)\s*$}) do
          fence = Regexp.last_match(1)
          heading = Regexp.last_match(2)
          anchor_id = Regexp.last_match(3)
          anchors_fixed += 1
          "#{fence}\n#{heading} {: ##{anchor_id} }"
        end

        # Pattern 1: Heading with trailing anchor link
        # "## method_name() [](#anchor-id)" -> "## method_name() {: #anchor-id }"
        # Use %r{} to avoid # interpolation issues in regex
        content.gsub!(%r{^(\#{1,6}\s+.+?)\s*\[\]\(\#([^)]+)\)\s*$}) do
          heading = Regexp.last_match(1)
          anchor_id = Regexp.last_match(2)
          anchors_fixed += 1
          "#{heading} {: ##{anchor_id} }"
        end

        # Pattern 2: Attribute headings with [RW]/[R]/[W] markers
        # "## attr_name[RW] [](#attribute-i-attr_name)" -> "## attr_name [RW] {: #attribute-i-attr_name }"
        content.gsub!(%r{^(\#{1,6}\s+\w+)\[([RW]+)\]\s*\[\]\(\#([^)]+)\)\s*$}) do
          heading = Regexp.last_match(1)
          rw_marker = Regexp.last_match(2)
          anchor_id = Regexp.last_match(3)
          anchors_fixed += 1
          "#{heading} [#{rw_marker}] {: ##{anchor_id} }"
        end

        # Pattern 3: Escape YARD annotations to prevent GitHub @mention linking
        # "**@param**" -> "**`@param`**" (inline code prevents magiclink processing)
        # Common YARD tags: @param, @return, @raise, @yield, @yieldparam, @yieldreturn,
        #                   @option, @overload, @example, @see, @note, @todo, @deprecated
        yard_tags = %w[param return raise yield yieldparam yieldreturn option overload example see note todo deprecated abstract api author since version private]
        yard_tags.each do |tag|
          # Match **@tag** and replace with **`@tag`**
          if content.gsub!(/\*\*@#{tag}\*\*/i, "**`@#{tag}`**")
            mentions_escaped += 1
          end
        end

        if content != original
          File.write(file, content)
          files_fixed += 1
        end
      end

      if files_fixed > 0
        puts "Fixed #{anchors_fixed} anchors in #{files_fixed} files for MkDocs compatibility"
        puts "Escaped #{mentions_escaped} YARD annotations to prevent @mention linking" if mentions_escaped > 0
      end
    end

    def create_yard_index_page(yard_output_dir)
      # Generate list of documented classes/modules from YARD output
      class_list = extract_yard_classes(yard_output_dir)

      content = <<~MARKDOWN
        # YARD API Reference

        Complete API documentation generated by [YARD](https://yardoc.org/) with [yard-markdown](https://github.com/skatkov/yard-markdown).

        <div class="grid cards" markdown>

        -   :material-book-open-variant:{ .lg .middle } **API Documentation**

            ---

            Browse the complete API reference with method signatures, parameters, and examples.

        -   :material-chart-bar:{ .lg .middle } **Documentation Coverage**

            ---

            Run `rake htm:doc:stats` to see documentation coverage statistics.

        </div>

        ## Classes & Modules

        | Class/Module | Description |
        |--------------|-------------|
        #{class_list}

        ## Generating Documentation

        ```bash
        # Build YARD documentation
        rake htm:doc:yard

        # Start live-reload server (HTML mode)
        rake htm:doc:server

        # Show coverage statistics
        rake htm:doc:stats
        ```
      MARKDOWN

      File.write("docs/api/yard-reference.md", content)
    end

    def extract_yard_classes(yard_output_dir)
      # Class descriptions for known classes
      descriptions = {
        "HTM" => "Main API class for memory operations",
        "Configuration" => "Multi-provider LLM configuration",
        "Database" => "Database schema and connection management",
        "EmbeddingService" => "Vector embedding generation service",
        "LongTermMemory" => "PostgreSQL-backed permanent storage",
        "WorkingMemory" => "Token-limited in-memory cache",
        "TagService" => "Hierarchical tag extraction service",
        "Observability" => "Metrics and logging instrumentation",
        "CircuitBreaker" => "Fault tolerance for external services",
        "Timeframe" => "Time-based query filtering",
        "TimeframeExtractor" => "Natural language time parsing",
        "JobAdapter" => "Background job abstraction layer"
      }

      # Dynamically discover classes from YARD markdown output
      classes = []

      # Check for markdown files in output directory
      Dir.glob(File.join(yard_output_dir, "**/*.md")).sort.each do |file|
        relative_path = file.sub("#{yard_output_dir}/", "")
        basename = File.basename(file, ".md")

        # Skip index files and non-class files
        next if basename == "index" || basename == "_index"
        next if basename.start_with?("_")

        # Determine class name from path
        class_name = relative_path.sub(".md", "").gsub("/", "::")

        # Skip error classes and internal classes
        next if class_name.end_with?("Error")
        next if class_name.include?("Railtie")
        next if class_name.include?("ActiveRecordConfig")

        # Get description
        simple_name = basename
        desc = descriptions[simple_name] || "#{class_name} class"

        classes << [class_name, desc, "yard/#{relative_path}"]
      end

      # If no markdown files found, fall back to checking for HTML (in case yard-markdown not installed)
      if classes.empty?
        htm_file = File.join(yard_output_dir, "HTM.html")
        if File.exist?(htm_file)
          classes << ["HTM", descriptions["HTM"] || "Main module", "yard/HTM.html"]
        end

        htm_dir = File.join(yard_output_dir, "HTM")
        if Dir.exist?(htm_dir)
          Dir.glob(File.join(htm_dir, "*.html")).sort.each do |file|
            basename = File.basename(file, ".html")
            next if basename.end_with?("Error")
            next if basename == "Railtie"
            next if basename == "ActiveRecordConfig"

            desc = descriptions[basename] || "#{basename} class"
            classes << ["HTM::#{basename}", desc, "yard/HTM/#{basename}.html"]
          end
        end
      end

      classes.map do |name, desc, path|
        "| [#{name}](#{path}) | #{desc} |"
      end.join("\n")
    end

    desc "Start YARD documentation server (live reload)"
    task :server, [:port] do |_t, args|
      port = args[:port] || 8808

      puts "Starting YARD documentation server on http://localhost:#{port}"
      puts "Press Ctrl+C to stop"
      puts

      exec("yard server --reload --port #{port}")
    end

    desc "Show documentation coverage statistics"
    task :stats do
      puts "YARD Documentation Coverage:"
      puts
      system("yard stats --list-undoc lib/**/*.rb")
    end

    desc "Fix YARD anchor links for MkDocs compatibility"
    task :fix_anchors do
      output_dir = "docs/api/yard"

      unless Dir.exist?(output_dir)
        puts "YARD output directory not found: #{output_dir}"
        puts "Run 'rake htm:doc:yard' first to generate documentation"
        exit 1
      end

      fix_yard_anchors_for_mkdocs(output_dir)
      puts "Done! Run 'mkdocs build' to verify no anchor warnings."
    end

    desc "Clean generated documentation"
    task :clean do
      require "fileutils"

      dirs_to_clean = ["docs/api/yard", ".yardoc"]
      files_to_clean = ["docs/api/yard-reference.md"]

      dirs_to_clean.each do |dir|
        if Dir.exist?(dir)
          FileUtils.rm_rf(dir)
          puts "Removed: #{dir}"
        end
      end

      files_to_clean.each do |file|
        if File.exist?(file)
          FileUtils.rm(file)
          puts "Removed: #{file}"
        end
      end

      puts "Documentation cleaned."
    end
  end
end
